---
title: csapp第六章-计算机运算方式
date: '2021-03-29'
author: serrini
showToc: true
TocOpen: false
draft: false
tags:
- 组成原理
categories:
- CSAPP
---
# 第六章 计算机运算方式
## 6.1 无符号数和有符号数
#### 无符号数
	8位，0-255
	16位，0-65536，有符号数16位表示范围-32768~+32767
#### 有符号数
	分整数和小数
	[+0.0000]原=0.0000
	[-0.0000]原=1.0000
	所以[+0]原 不等于 [-0]原

### 补码表示法
	+9是-3以12为模的补数
	-3		+9(mod 12)
	-4		+8(mod 12)
	-5		+7
	这样就可以把减法运算用加法实现
	结论
		负数加上模，得到负数的补数，如-5+12=+7
		一个整数和一个负数如果互为补数，他们绝对值的和是模，5+7=12

	规定寄存器位数是4，模就是16，大于16进位的部分就会被丢掉
	1011变成0
		1011-1011 = 0000
		1011+0101 = 10000	最高位被丢掉，0000
		所以-1011操作可以替换成+0101，0101是-1011的补数
		[-1011]原 = 11011
		[-1011]补 = 10101

		[+0101]补 = [-0101]补 = 0101 如何表示？
			[+0101]补 = 0,0101
			[-0101]补 = 1,0101
			
	小数补码
		x=-1 	[-1]补 = 2+x = 10.0000-1.0000 = 1.0000
		-1不属于小数范围，但[-1]补却存在，由于补码的0只有一种表示形式，故它比原码能多表示一个-1

		已知补码可以求真值
			[x]补 = x+2 				->		 x = [x]补-2
			[x]补 = 2^(n+1) + x		->		 x = [x]补-2^(n+1)
			已知[x]补= 0.0001，正数，所以X真值=+0.0001
			已知[x]补= 1.0001，负数，所以真值=-0.1111
				符号位保持不变，每位取反，末尾加一，原码1.1110
			已知[x]补= 1.1110

### 反码表示法

#### 真值为正时，原码、补码和反码表示形式相同，符号位0，数值部分和真值相同
真值为负时，符号位都1，数值部分按位取反

x=+1101 	[x]反=0,1101
x=-1101 	[x]反=1,0010
x=+0.0110	[x]反=0.0110
x=-0.0110 	[x]反=1.1001
x=0时
	[+0.0000]反 = 0.0000
	[-0.0000]反 = 1.1111

#### *设机器数字长8位，含1符号位，对于整数，当其分别代表无符号数、原码、补码和反码时，对应的真值范围？

#### *由[y]补求[-y]补？
	连同符号位在内，每位取反，末尾加1	------结论*

### 移码表示法
难以从补码的形式上直接判断其真值的大小

[x]移 = 2^n + x

x=10100

	[x]移=2^5+10100=1,10100

x=-10100

	[x]移=2^5-10100=0,01100

x=0

	[+0]移=2^5+0=1,00000
	[-0]移=2^5-0=1,00000	
	移码中0的表示唯一

特征
	最小真值得译码全为0
	同一真值得移码和补码只差一个符号位

## 6.2 数的定点表示和浮点表示
### 6.2.1 定点表示
纯小数
纯整数
定点机

### 6.2.2 浮点表示
#### 浮点数的尾数采用纯小数形式，尾数最高位为1的浮点数成为规格化数，浮点数表示成规格化形式后，其精度最高
	浮点数的表示范围
		“上溢”“下溢”
		短实数32位，阶码8，尾数24
		长实数64位，阶码11，尾数53
		临时实数80位，阶码15，尾数65
	浮点数的规格化

#### * 阶符，阶码的数值部分(m位)；数符，尾数的数值部分(n位)

#### 举例
x=+(13/128)	？？

x=-54

	二进制表示 			x=-110110
	定点数表示 			x=-0000110110
	浮点数规格化表示 		x=-(0.1101100000)x2^110
	定点机中
		[x]原 = 1,0000110110
		[x]补 = 1,1111001010
		[x]反 = 1,1111001001
	浮点机中
		[x]原 = 0,0110;1.1101100000
		[x]补 = 0,0110;1.0010100000
		[x]反 = 0,0110;1.0010011111

n=10,m=4,阶符数符各取1位，表示范围 (了解)

	最大正数	0,1111;0.1111111111
	最小正数 1,0001;0.0000000001
	最大负数 1,0001;1.1111111111
	最小负数 0,1111;1.0000000001

浮点数字长16位，阶码5位，含1阶符，尾数11位，含1数符。

写出x=-(53/512)对应的浮点规格化数的原码、补码、反码和阶码用移码，尾数用补码的形式。
？

注意，只要一个浮点数尾数是0，“机器零”

### 6.2.5 IEEE754标准
																			偏置值
							数符		阶符 	尾数数值 	总尾数		十六进制		  十进制
短浮点数（单精度，float）		 1 		 8                       23           32                              7FH	                   127
长浮点数（双精度，double）    	 1 		 11                     52           64		          3FFH                       1023
临时浮点数				 1                       15                     64            80                              3FFFH                      16383


IEEE754标准尾数采用隐藏位策略的原码表示，阶码用移码表示的浮点数

规格化的二进制浮点数，数值位最高位总是1，可以隐藏起来，多表示一位有效位，短浮点数和长浮点数都隐含，临时浮点数又称扩展精度浮点数，无隐含位。

阶码是用移码表示的，所以阶码值3

	短浮点数中，移码表示的阶码是127+3=130（16进制表示是82）
	长浮点数中，移码表示的阶码是1023+3=1026（16进制表示是402）

IEEE754标准中，规格化的短浮点数真值是(-1)^s * 1.M * 2^(E-127)
			  规格化的长浮点数真值是(-1)^s * 1.M * 2^(E-1023)

## 6.3 定点运算

### 6.3.1 算术移位
	规则
		负数原码，移位时符号位不变，空位添0
		负数反码，除符合位外与负数原码正好相反，所以移位后代码与原码相反，全添1
		负数补码，左移则低位的空位添0，右移则高位的空位添1
	举例
		机器数字长8位，含1符号位，A=+-26，三种机器数左右移一位和两位后的表达形式及对应的真值
		A=+26=(+11010)
			A原补反 = 0,0011010
			左移一位  0,0110100
			左移两位  0,1101000
			右移一位  0,0001101
			右移两位  0,0000110
		A=-26=(-11010)
			原        1,0011010
			左移一位   1,0110100 
			左移两位   1,1101000
			右移一位   1,0001101
			右移两位   1,0000110

			补 			1,1100110
			左移一位  	1,1001100		左移低位添0
			左移两位		1,0011000
			右移一位		1,1110011
			右移两位 	1,1111001		右移高位添1

			反 		   	1,1100101
			左移一位 	1,1001011
			左移两位		1,0010111
			右移一位		1,1110010
			右移两位		1,1111001

#### 算术移位和逻辑移位的区别

有符号数是算术，无符号数是逻辑

逻辑移位的规则
	
	左移低位添0，右移高位添0
	01010011 算术左移，符号位不变，0,0100110
		为了防止最高位的1丢失，就把符号位移至Cy，算术移位后就是0,10100110

### 6.3.2 加法与减法运算
用补码作减法运算
补码表示的两个数在进行加法运算时，符号位和数位同等处理
举例
	已知A=0.1011，B=-0.0101，求[A+B]补
		A补=2+x=1.1111+0.1011=？
		A补=0.1011
		B补=1.1010+0.0001=1.1011
		A补+B补 = 0.1011+1.1011 = 10.0110，最高位1丢掉，0.0110
		模2^(4+1)，最高位1丢掉
	已知A=-1001，B=-0101，求[A+B]补
		A补=1,0111
		B补=1,1011
		A补+B补 = 1,0111+1,1011 = 11,0010，最高位1丢掉，1,0010
	设机器数字长8位，含1符号位，A=+15，B=+24，求[A-B]补并还原成真值
		A=0,0001111
		B=0,0011000 	-B=0,1100111
		A补=0,0001111
		B补=0,0011000
		[-B]补=0,1100111
		A补=0,0001111
		[A-B]补 = 0,1100111 + 0,0001111 = 0,1100110


